//
// Copyright 2020 DXOS.org
//

syntax = "proto3";

package dxos.halo.credentials;

import "google/protobuf/timestamp.proto";
import "@dxos/protocols/src/proto/dxos/halo/keys.proto";

/**
 * Represents a claim with a set of cryptographic signatures.
 *
 * Loosely inspired by [W3C Verifiable-Credentials](https://www.w3.org/TR/vc-data-model/).
 */
message Credential {
  /// Timestamp of when this credential was created.
  google.protobuf.Timestamp issued = 1;

  /// Credential claim. 
  google.protobuf.Any claim = 2;

  /**
   * List of signatures for this credential.
   * The credential issuer(s) can be derrived from this list.
   *
   * New signatures may be appended to the list to allow for credential presentation 
   * and to have delegated credentials
   * (i.e., credential issued by the subject and then signed by an authority).
   * TODO(dmaretskyi): In contrast to Envelope credentials
   * this does not allow to limit the scope of the credential (e.g., set the party key).
   */
  repeated Proof proofs = 10;
}

/// Input data for the signature.
message SignedData {
  /// Credential with the proofs fields ommited.
  Credential credential = 1;

  google.protobuf.Timestamp created = 2;

  optional bytes nonce = 3;
}

message Proof {
  /// Signature type. Must be equal to "ED25519".
  string type = 1;

  /// Public key of the signer.
  dxos.halo.keys.PubKey signer = 2;
  
  /// Timestamp of when the signature was performed.
  google.protobuf.Timestamp created = 3;

  /**
   * Optional nonce. 
   *
   * In interactive presentation protcols may be set to the challenge.
   */
  optional bytes nonce = 4;
  
  /**
   * Signature data itself.
   *
   * Serialized SignedData message is used as an input to the signature.
   * Protobuf encoding is not stable across implementations.
   */
  bytes signature = 10;
}
