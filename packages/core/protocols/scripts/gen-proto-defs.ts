//
// Copyright 2022 DXOS.org
//

import fs from 'fs';
import glob from 'glob';
import path from 'path';

const HEADER = '// Generated file: do not edit.';

// NOTE: Proto package names must match the generated folder tree.
// TODO(burdon): Warn if does not match.

/**
 * Use "exports" in package.json.
 */
const PACKAGE_EXPORTS = true;

/**
 * Generate protocol buffer definition files.
 */
const main = (
  pattern: string,
  prefix = './src/proto',
  dist = './dist/src/proto/gen',
  outdir = './proto'
) => {
  // https://nodejs.org/api/fs.html
  // https://nodejs.org/api/path.html
  fs.rmSync(outdir, { recursive: true, force: true });

  if (!PACKAGE_EXPORTS) {
    fs.mkdirSync(outdir);

    // Create README.
    // TODO(burdon): Move to toolchain.
    fs.writeFileSync(
      path.join(outdir, 'README.md'),
      '# Protobuf Defs\n\nGenerated by script:\n\n```bash\npnpm nx gen-proto-defs protocols\n```\n');
  }

  // https://www.npmjs.com/package/glob
  const files = glob.sync(pattern);

  if (PACKAGE_EXPORTS) {
    const exports = {
      '.': {
        default: './dist/src/index.js',
        types: './dist/src/index.d.ts'
      }
    };
    for (const file of files) {
      const idx = file.indexOf(prefix);
      if (idx !== 0) {
        continue;
      }
      const sub = file.substr(prefix.length + 1);
      const dir = path.join(outdir, path.dirname(sub));
      const filename = path.basename(sub, '.proto');
      const exportFile = path.join(path.dirname(sub), filename);

      exports['./' + path.join(dir, filename)] = {
        default: './' + path.join('dist/src/proto/gen', `${exportFile}.js`),
        types: './' + path.join('dist/src/proto/gen', `${exportFile}.d.ts`)
      };
    }

    const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
    packageJson.exports = exports;
    fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2));
  } else {
    for (const file of files) {
      const idx = file.indexOf(prefix);
      if (idx === 0) {
        // Output directory.
        const sub = file.substr(prefix.length + 1);
        const dir = path.join(outdir, path.dirname(sub));
        if (!fs.existsSync(dir)) {
          fs.mkdirSync(dir, { recursive: true });
        }

        // Output file.
        const filename = path.basename(sub, '.proto');
        const jsOutFile = path.join(dir, `${filename}.js`);
        const tsOutFile = path.join(dir, `${filename}.d.ts`);
        const mapOutFile = path.join(dir, `${filename}.d.ts.map`);

        // Relative path.
        const exportFile = path.join(path.dirname(sub), filename);
        const relative = path.join(path.relative(exportFile, '.'), dist, exportFile);

        // JS compiled output (required for tests).
        fs.writeFileSync(jsOutFile, `${HEADER}\nmodule.exports = require('${relative}');\n`);

        // TS definitions.
        fs.writeFileSync(tsOutFile, `${HEADER}\nexport * from '${relative}';\n`);

        // Source map definitions (enables IDE navigation in VSCode).
        // https://github.com/source-map/source-map-spec
        fs.writeFileSync(mapOutFile, JSON.stringify({
          'version': 3,
          'file': `${filename}.d.ts`,
          'sourceRoot': '',
          'sources': [
            path.join(path.relative(exportFile, '.'), prefix, sub)
          ],
          'names': [],
          'mappings': 'AAIA,cAAc,SAAS,CAAC;AACxB,cAAc,cAAc,CAAC;AAC7B,cAAc,aAAa,CAAC'
        }, undefined, 2) + '\n');
      }
    }
  }
};

main('./src/proto/**/*.proto');
